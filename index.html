<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ‘» ì—ì½” ì í¼ (v6.2 - ë‚œì´ë„ í•˜í–¥)</title>
    <style>
        /* --- ê¸°ë³¸ ë° ë ˆì´ì•„ì›ƒ --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #000; /* ê²€ì€ìƒ‰ ë°°ê²½ */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'DotGothic16', 'Courier New', monospace; /* í”½ì…€ í°íŠ¸ */
            touch-action: none; 
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px; 
            height: 100%;
            max-height: 900px; 
            overflow: hidden;
            background-color: #2a2a3e; /* ë¬˜ì§€ ë°°ê²½ìƒ‰ */
            border: 2px solid #50507a;
            transition: background-color 0.1s; /* ë ˆë²¨ì—… í”Œë˜ì‹œìš© */
        }

        #game-canvas {
            display: block;
            cursor: none;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        /* --- UI ì˜ì—­ --- */
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        
        #gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 0; 
            overflow: hidden;
            display: none; 
        }

        #gauge-bar {
            width: 100%;
            height: 100%;
            background-color: #00FFFF; /* ì‹œì•ˆìƒ‰ */
            transition: width 0.1s linear;
        }

        #top-ui {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px #000;
            z-index: 5;
            pointer-events: none; 
        }
        
        #exp-bar {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 5px;
            background-color: #FFFF00; 
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.2s ease;
            z-index: 6;
        }
        
        #core-hp-container {
            position: absolute;
            top: 45px; 
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            text-align: center;
            z-index: 5;
            pointer-events: none;
        }
        
        #core-hp-container div {
            font-size: 1em;
            font-weight: bold;
            color: #FF00FF; 
            text-shadow: 1px 1px #000;
        }
        
        #core-hp-bar-outer {
            width: 100%;
            height: 10px;
            border: 2px solid #FF00FF;
            background-color: #333;
        }
        
        #core-hp-bar-inner {
            width: 100%;
            height: 100%;
            background-color: #FF00FF;
            transition: width 0.2s;
        }


        /* --- ì˜¤ë²„ë ˆì´ ê³µí†µ --- */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease, visibility 0.3s;
            visibility: hidden;
            opacity: 0;
            z-index: 10;
            padding: 20px; /* â—€â—€â—€ ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš” */
            box-sizing: border-box; /* â—€â—€â—€ ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš” */
        }

        .overlay.visible {
            visibility: visible;
            opacity: 1;
        }
        
        #overlay-content-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
            max-height: 90%; 
            overflow: hidden; 
        }


        /* --- ì‹œì‘/ì¢…ë£Œ ì˜¤ë²„ë ˆì´ --- */
        #game-overlay h1 {
            color: #00FFFF; 
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        #game-overlay p {
            font-size: 1.1em;
            margin: 10px 0;
            flex-shrink: 0;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #1a1a2e;
            background-color: #00FFFF;
            border: 2px solid #fff;
            border-radius: 0; 
            cursor: pointer;
            box-shadow: 0 0 20px #00FFFF;
            margin-top: 20px;
            flex-shrink: 0;
        }

        #final-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #FF00FF; 
            margin: 10px 0;
            flex-shrink: 0;
        }
        
        #best-time-display {
            font-size: 1.1em;
            color: #FFFF00;
            margin: 0;
        }
        
        #info-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            z-index: 11;
        }
        
        /* 'ê²Œì„ ë°©ë²•' UI */
        #instructions {
            display: none; 
            flex-grow: 1; 
            width: 100%;
            max-width: 500px; 
            overflow-y: auto; 
            text-align: left;
            padding: 10px;
            padding-right: 20px; 
            border-top: 1px solid #50507a;
            border-bottom: 1px solid #50507a;
            box-sizing: border-box;
        }
        
        #instructions h3 {
            color: #00FFFF;
            border-bottom: 1px solid #00FFFF;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        #instructions ul {
            padding-left: 20px;
            margin: 0 0 15px 0;
        }
        
        #instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        #instructions b {
            color: #FFFF00; 
        }
        
        #instructions code {
            background-color: #000;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        /* --- ë ˆë²¨ ì—… ì˜¤ë²„ë ˆì´ --- */
        #level-up-overlay {
            justify-content: center;
            gap: 20px;
        }
        
        #level-up-title {
            color: #FFFF00;
            font-size: 2em;
            text-shadow: 2px 2px #000;
        }
        
        .upgrade-card {
            width: 80%;
            max-width: 300px;
            background-color: #1a1a2e;
            border: 3px solid #00FFFF;
            padding: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center; /* â—€â—€â—€ ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš” */
            box-sizing: border-box; /* â—€â—€â—€ ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš” */
        }
        
        .upgrade-card:hover {
            background-color: #3a3a5e;
        }
        
        .upgrade-card h3 {
            margin: 0 0 10px 0;
            color: #FFFF00;
        }
        
        .upgrade-card p {
            margin: 0;
            font-size: 1em;
            color: #eee;
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        
        <button id="info-button">?</button>

        <div id="top-ui">
            <div id="time-display">Time: 0</div>
            <div id="level">Lv. 1</div>
        </div>
        
        <div id="core-hp-container">
            <div>ğŸ’ SOUL CORE</div>
            <div id="core-hp-bar-outer">
                <div id="core-hp-bar-inner"></div>
            </div>
        </div>
        
        <div id="exp-bar"></div>

        <canvas id="game-canvas"></canvas>

        <div id="ui-container">
            <div id="gauge-container">
                <div id="gauge-bar"></div>
            </div>
        </div>
        
        <div id="game-overlay" class="overlay visible">
            <div id="overlay-content-wrapper">
                <h1>ğŸ‘» ì—ì½” ì í¼ ğŸ‘»</h1>
                <p id="best-time-display">Best Time: 0</p>
                <p id="overlay-message">
                    ì¤‘ì•™ì˜ 'ì˜í˜¼ í•µ(ğŸ’)'ì„ ì§€í‚¤ì„¸ìš”!<br>
                    ì ì—ê²Œ ë¹™ì˜í•˜ì—¬ í•µìœ¼ë¡œ ê°€ëŠ” ì ë“¤ì„ ì²˜ì¹˜í•˜ì„¸ìš”.
                </p>
                
                <div id="instructions">
                    <h3>ğŸ•¹ï¸ ì¡°ì‘ ë°©ë²• (Controls)</h3>
                    <h4>ğŸ–¥ï¸ PC (í‚¤ë³´ë“œ + ë§ˆìš°ìŠ¤)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ ì›€ì§ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜/í•´ì œ:</b> <code>ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­</code></li>
                    </ul>
                    <h4>ğŸ“± ëª¨ë°”ì¼ (í„°ì¹˜ìŠ¤í¬ë¦°)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì†ê°€ë½ìœ¼ë¡œ ë“œë˜ê·¸</code>í•˜ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜/í•´ì œ:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì§§ê²Œ íƒ­(Tap)</code>í•©ë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>1. ê¸°ë³¸ í”Œë ˆì´ ë°©ë²• (Push & Pull)</h3>
                    <ul>
                        <li><b>ê²Œì„ ëª©í‘œ:</b> ë§µ ì¤‘ì•™ì˜ <b>'ì˜í˜¼ í•µ(ğŸ’)'</b>ì„ ëª¬ìŠ¤í„°ë¡œë¶€í„° ì§€í‚¤ëŠ” ê²ƒì…ë‹ˆë‹¤. í•µì˜ HPê°€ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„ì…ë‹ˆë‹¤.</li>
                        <li><b>ìœ ë ¹ (ğŸ”µ):</b> í”Œë ˆì´ì–´ì˜ ê¸°ë³¸ ìƒíƒœì…ë‹ˆë‹¤. ì´ ìƒíƒœì—ì„œëŠ” <b>ë¬´ì </b>ì´ë©° <b>ê²½í—˜ì¹˜(ğŸ’)ë¥¼ ìˆ˜ì§‘</b>í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><b>ìˆ™ì£¼ (â—»ï¸ğŸ”µ):</b> <b>ê³µê²©</b>ì„ í•  ìˆ˜ ìˆëŠ” ìœ ì¼í•œ ìƒíƒœì…ë‹ˆë‹¤. <b>ê²½í—˜ì¹˜ë¥¼ ìˆ˜ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</b></li>
                        <li><b>ë¹™ì˜ (Push):</b> ìœ ë ¹ ìƒíƒœì—ì„œ íƒ­/í´ë¦­í•˜ë©´ ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ **ë¹ ë¥´ê²Œ ëŒì§„**í•˜ì—¬ 'ë¹™ì˜'í•©ë‹ˆë‹¤.</li>
                        <li><b>ë¹™ì˜ í•´ì œ (Pull):</b> ìˆ™ì£¼ ìƒíƒœì—ì„œ íƒ­/í´ë¦­í•˜ë©´, <b>ì¦‰ì‹œ ë¹™ì˜ë¥¼ í•´ì œ</b>í•˜ê³  ì•ˆì „í•œ 'ë¬´ì  ìœ ë ¹' ìƒíƒœë¡œ ëŒì•„ì˜µë‹ˆë‹¤.</li>
                        <li><b>(ì¤‘ìš”) ìˆ™ì£¼ í”¼ê²©:</b> ìˆ™ì£¼ ìƒíƒœì—ì„œ ì ê³¼ ë‹¿ìœ¼ë©´, ê²Œì´ì§€ê°€ ì¶”ê°€ë¡œ <b>ë” ë¹¨ë¦¬ ë‹³ìŠµë‹ˆë‹¤!</b></li>
                    </ul>
                    
                    <h3>2. ëª¬ìŠ¤í„°(ìˆ™ì£¼) íŠ¹ì§•</h3>
                    <ul>
                        <li><b>â—»ï¸ ìŠ¤ì¼ˆë ˆí†¤ (HP: 2):</b> [ë°¸ëŸ°ìŠ¤í˜•] ê°€ê¹Œìš´ ì ì—ê²Œ ë¼ˆë‹¤ê·€ë¥¼ ë˜ì§‘ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸ© ì¢€ë¹„ (HP: 5):</b> [ê´‘ì—­/ë°©ì–´í˜•] ì£¼ë³€ì— 'ë¶€íŒ¨ ì˜¤ë¼'ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤. ê²Œì´ì§€ê°€ ë§¤ìš° ê¹ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸª ë°•ì¥ (HP: 1):</b> [ê¸°ë™/ê´€í†µí˜•] ê°€ê¹Œìš´ ì ì—ê²Œ ë¹ ë¥¸ 'ì´ˆìŒíŒŒ'ë¥¼ ì©ë‹ˆë‹¤. ì´ë™ ì†ë„ê°€ ë¹ ë¦…ë‹ˆë‹¤.</li>
                        <li><b>ğŸ©¶ ê°€ê³ ì¼ (HP: 10):</b> [ê´‘ì—­/ë°©ì–´í˜•] 2ì´ˆë§ˆë‹¤ ì£¼ë³€ì— 'ì§€ì§„'ì„ ì¼ìœ¼ì¼œ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤. ê²Œì´ì§€ê°€ ë§¤ìš° ê¹ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸ¢ ìŠ¬ë¼ì„ (HP: 6):</b> [íƒ±ì»¤] ëŠë¦° 'ìŠ¬ë¼ì„ë³¼'ì„ ì©ë‹ˆë‹¤. ë§¤ìš° ëŠë¦¬ê³  íŠ¼íŠ¼í•©ë‹ˆë‹¤.</li>
                        <li><b>â¤ï¸ ì„í”„ (HP: 1):</b> [ìœ ë¦¬ëŒ€í¬] ê°•ë ¥í•œ 'íŒŒì´ì–´ë³¼'ì„ ì©ë‹ˆë‹¤. ë¹ ë¥´ì§€ë§Œ ê²Œì´ì§€ê°€ ì§§ìŠµë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>â­ 3. ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„° â­</h3>
                    <ul>
                        <li>ë‚®ì€ í™•ë¥ ë¡œ <b>ë…¸ë€ìƒ‰(ğŸŸ¡)</b>ìœ¼ë¡œ ë¹›ë‚˜ë©° <b>ì™•ê´€(ğŸ‘‘)</b>ì„ ì“´ 'ì—˜ë¦¬íŠ¸' ëª¬ìŠ¤í„°ê°€ ë“±ì¥í•©ë‹ˆë‹¤. (HP 2ë°°)</li>
                        <li>ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„°ëŠ” <b>ê¸°ë³¸ HP ë³´ë„ˆìŠ¤(+5)</b>ë¥¼ ë°›ìœ¼ë©°, ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë” ê°•í•´ì§‘ë‹ˆë‹¤.</li>
                        <li>ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„°ì—ê²Œ ë¹™ì˜í•˜ë©´ <b>ê°•í™”ëœ ìŠ¤í‚¬</b>ì„ ì‚¬ìš©í•©ë‹ˆë‹¤!</li>
                        <li>(ì˜ˆ: "íŠ¸ë¦¬í”Œ ìƒ·", "ì˜í˜¼ ìˆ˜ë³µ" ë“±)</li>
                    </ul>
                </div>
                
                <p id="final-score"></p>
                <button id="start-button">ì‹œì‘í•˜ê¸°</button>
            </div>
        </div>
        
        <div id="level-up-overlay" class="overlay">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <div class="upgrade-card" data-upgrade="0">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="1">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="2">
                <h3></h3>
                <p></p>
            </div>
        </div>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- DOM ìš”ì†Œ ---
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            const gameOverlay = document.getElementById('game-overlay');
            const overlayContent = document.getElementById('overlay-content-wrapper');
            const startButton = document.getElementById('start-button');
            const finalScoreDisplay = document.getElementById('final-score');
            const bestTimeDisplay = document.getElementById('best-time-display');
            const infoButton = document.getElementById('info-button');
            const instructions = document.getElementById('instructions');
            const overlayMessage = document.getElementById('overlay-message');
            
            const timeDisplay = document.getElementById('time-display');
            const levelDisplay = document.getElementById('level');
            const expBar = document.getElementById('exp-bar');
            const gaugeContainer = document.getElementById('gauge-container');
            const gaugeBar = document.getElementById('gauge-bar');
            const coreHpBar = document.getElementById('core-hp-bar-inner');
            
            const levelUpOverlay = document.getElementById('level-up-overlay');
            const upgradeCards = document.querySelectorAll('.upgrade-card');

            // --- ìº”ë²„ìŠ¤ í¬ê¸° ---
            const VIEWPORT_WIDTH = gameContainer.clientWidth;
            const VIEWPORT_HEIGHT = gameContainer.clientHeight;
            const PIXEL_SCALE = 3; 
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;
            ctx.imageSmoothingEnabled = false;

            // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
            let gameState = 'START'; 
            let gameTime = 0; 
            let gameLoopId = null;
            let frameCount = 0;
            let gameTimerInterval = null; 
            
            let spawnInterval = 180; 
            let nextSpawnFrame = spawnInterval;
            let waveCount = 1;
            let eliteSpawnChance = 0.1; 

            let player, enemies, projectiles, echoes, particles, soulCore;

            const BEST_TIME_KEY = 'echoJumperBestTime';
            let targetPos = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2 };

            // --- ëª¬ìŠ¤í„°/í”Œë ˆì´ì–´/ì—…ê·¸ë ˆì´ë“œ ì •ì˜ (ìˆ˜ì •ë¨) ---
            const PLAYER_COLOR = '#00FFFF';
            const PLAYER_RADIUS = 3 * PIXEL_SCALE; // (ìˆ˜ì •) 4 -> 3
            const PLAYER_SPEED_WISP = 3.0; 
            const PLAYER_DASH_SPEED = 10; 
            const ELITE_COLOR = '#FFFF00'; 
            const CROWN_SPRITE = ['111','101','010']; 

            const MOB_PROPERTIES = {
                'skeleton': { gauge: 1000, attackType: 'bone', attackCooldown: 60, speed: 1.5, hp: 2, exp: 10, 
                    sprite: ['0110','1111','0110','0110','1001'], color: '#FFFFFF' },
                'zombie': { gauge: 1800, attackType: 'aura', attackCooldown: 10, speed: 0.8, hp: 5, exp: 20,
                    sprite: ['0110','1111','0110','1111','1001'], color: '#32CD32' },
                'bat': { gauge: 600, attackType: 'sonic', attackCooldown: 40, speed: 2.5, hp: 1, exp: 10, 
                    sprite: ['10101','01110','00100'], color: '#9400D3' }, 
                'gargoyle': { gauge: 4000, attackType: 'stomp', attackCooldown: 120, speed: 0.5, hp: 10, exp: 30,
                    sprite: ['01110','11111','11011','01110','01010'], color: '#888888' },
                'slime': { gauge: 1500, attackType: 'slimeball', attackCooldown: 80, speed: 0.5, hp: 6, exp: 25, 
                    sprite: ['0110','1111','1111','0110'], color: '#ADFF2F' }, 
                'imp': { gauge: 700, attackType: 'fireball', attackCooldown: 100, speed: 2.0, hp: 1, exp: 15, 
                    sprite: ['101','010','101'], color: '#FF4500' } 
            };
            const MOB_TYPES = Object.keys(MOB_PROPERTIES);
            
            // (ìˆ˜ì •) ì—…ê·¸ë ˆì´ë“œ í’€ (v6.1 ê¸°ì¤€)
            const UPGRADE_POOL = [
                { id: 'gauge_1', title: 'ìˆ™ì£¼ ì•ˆì •í™” I', desc: 'ë¹™ì˜ ê²Œì´ì§€ ì´ëŸ‰ì´ 20% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.maxGaugeMult += 0.20 },
                { id: 'wisp_speed_1', title: 'ìœ ë ¹ ê¸°ë™ë ¥ I', desc: 'ìœ ë ¹ ìƒíƒœì˜ ì´ë™ ì†ë„ê°€ 20% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.wispSpeedMult += 0.20 },
                { id: 'jump_nova', title: 'ì†Œìš¸ ë…¸ë°”', desc: 'ìƒˆë¡œìš´ ìˆ™ì£¼ë¡œ \'ë¹™ì˜\'í•  ë•Œ ì£¼ë³€ì— í­ë°œì„ ì¼ìœ¼í‚µë‹ˆë‹¤.', apply: () => player.stats.jumpNova = true },
                { id: 'attack_speed_1', title: 'ê³µê²© ì†ë„ I', desc: 'ìˆ™ì£¼ì˜ ê³µê²© ì†ë„ê°€ 20% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.attackSpeedMult += 0.20 },
                { id: 'core_hp_1', title: 'ì˜í˜¼ í•µ ê°•í™” I', desc: 'ì˜í˜¼ í•µì˜ ìµœëŒ€ HPê°€ 20% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => {soulCore.maxHp *= 1.2; soulCore.heal(soulCore.maxHp * 0.2);} },
                { id: 'elite_chance_1', title: 'ë¶ˆì•ˆì •í•œ ì˜í˜¼', desc: 'ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„° ë“±ì¥ í™•ë¥ ì´ 5% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => eliteSpawnChance += 0.05 },
                { id: 'bone_damage_1', title: 'ë‚ ì¹´ë¡œìš´ ë¼ˆ I', desc: 'ìŠ¤ì¼ˆë ˆí†¤ì˜ ë¼ˆ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.boneDamage += 1 },
                { id: 'sonic_damage_1', title: 'ì´ˆìŒíŒŒ ê°•í™” I', desc: 'ë°•ì¥ì˜ ì´ˆìŒíŒŒ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.sonicDamage += 1 },
                { id: 'aura_size_1', title: 'ë¶€íŒ¨ ì˜¤ë¼ í™•ì¥ I', desc: 'ì¢€ë¹„ì˜ ì˜¤ë¼ ë²”ìœ„ê°€ 30% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.auraSizeMult += 0.30 },
                { id: 'imp_damage_1', title: 'ì§€ì˜¥ë¶ˆ I', desc: 'ì„í”„ì˜ íŒŒì´ì–´ë³¼ ë°ë¯¸ì§€ê°€ 2 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.fireballDamage += 2 },
                { id: 'slime_slow_1', title: 'ê°•ë ¥ ì ‘ì°©ì•¡', desc: 'ìŠ¬ë¼ì„ë³¼ì— ë§ì€ ì ì´ 1ì´ˆê°„ ëŠë ¤ì§‘ë‹ˆë‹¤.', apply: () => player.stats.slimeSlow = true },
                { id: 'pierce_1', title: 'ì˜í˜¼ ê´€í†µ', desc: 'ëª¨ë“  íˆ¬ì‚¬ì²´ê°€ ì  1ëª…ì„ ê´€í†µí•©ë‹ˆë‹¤.', apply: () => player.stats.pierce += 1 },
                { id: 'multi_shot_1', title: 'ë¶„ì—´ëœ ì˜í˜¼', desc: 'íˆ¬ì‚¬ì²´ +1 (ìŠ¤ì¼ˆë ˆí†¤, ë°•ì¥, ì„í”„)', apply: () => player.stats.multiShot += 1 },
                { id: 'cooldown_1', title: 'ê°€ì†í™”', desc: 'ëª¨ë“  ìˆ™ì£¼ ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ì´ 15% ê°ì†Œí•©ë‹ˆë‹¤.', apply: () => player.stats.cooldownMult += 0.15 },
            ];
            let currentUpgradeChoices = [];

            // --- í”½ì…€ ì•„íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
            function drawPixelSprite(spriteData, x, y, colorTint, isElite = false) {
                const spriteHeight = spriteData.length;
                const spriteWidth = spriteData[0].length;
                const scale = PIXEL_SCALE * (isElite ? 1.5 : 1); 
                
                const startX = Math.floor(x - (spriteWidth * scale) / 2);
                const startY = Math.floor(y - (spriteHeight * scale) / 2);

                if (colorTint) ctx.fillStyle = colorTint;
                
                for (let r = 0; r < spriteHeight; r++) {
                    for (let c = 0; c < spriteWidth; c++) {
                        if (spriteData[r][c] === '1') {
                            ctx.fillRect(startX + c * scale, startY + r * scale, scale, scale);
                        }
                    }
                }
                
                if (isElite) {
                    const crownY = startY - (CROWN_SPRITE.length * PIXEL_SCALE) - 2; 
                    const crownX = Math.floor(x - (CROWN_SPRITE[0].length * PIXEL_SCALE) / 2);
                    
                    ctx.fillStyle = ELITE_COLOR;
                    for (let r = 0; r < CROWN_SPRITE.length; r++) {
                        for (let c = 0; c < CROWN_SPRITE[r].length; c++) {
                            if (CROWN_SPRITE[r][c] === '1') {
                                ctx.fillRect(crownX + c * PIXEL_SCALE, crownY + r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                            }
                        }
                    }
                }
            }
            
            // --- í´ë˜ìŠ¤ ì •ì˜ ---
            class Player {
                constructor() { this.reset(); }
                reset() {
                    this.x = VIEWPORT_WIDTH / 2;
                    this.y = VIEWPORT_HEIGHT / 2 + 100; 
                    this.radius = PLAYER_RADIUS;
                    this.state = 'WISP'; 
                    this.hostType = null;
                    this.isEliteHost = false; 
                    this.gauge = 0;
                    this.maxGauge = 0;
                    this.speed = PLAYER_SPEED_WISP;
                    this.attackTimer = 0;
                    this.dashCooldown = 0;
                    this.unpossessTimer = 0;
                    this.level = 1;
                    this.experience = 0;
                    this.expToNextLevel = 50; // (ìˆ˜ì •) 100 -> 50
                    
                    this.dashTarget = null; 
                    
                    this.stats = {
                        maxGaugeMult: 1.0,
                        wispSpeedMult: 1.0,
                        attackSpeedMult: 1.0,
                        cooldownMult: 0.0, 
                        jumpNova: false,
                        auraSizeMult: 1.0,
                        boneDamage: 1,
                        sonicDamage: 1,
                        fireballDamage: 2,
                        slimeSlow: false,
                        pierce: 0, 
                        multiShot: 0, 
                    };
                }

                draw() {
                    ctx.shadowBlur = 10; 
                    if (this.state === 'WISP' || this.state === 'UNPOSSESSING' || this.state === 'DASHING') {
                        ctx.fillStyle = PLAYER_COLOR;
                        ctx.shadowColor = PLAYER_COLOR;
                        if(this.unpossessTimer > 0 && frameCount % 10 < 5) {
                             ctx.globalAlpha = 0.5; 
                        }
                        if (this.state === 'DASHING') { 
                            ctx.globalAlpha = 0.5;
                            particles.push(new Particle(this.x, this.y, 0, 0, 10, PLAYER_COLOR, 'trail'));
                        }
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    } else if (this.state === 'HOST') {
                        const spriteData = MOB_PROPERTIES[this.hostType].sprite;
                        ctx.shadowColor = this.isEliteHost ? ELITE_COLOR : PLAYER_COLOR;
                        drawPixelSprite(spriteData, this.x, this.y, PLAYER_COLOR, this.isEliteHost);
                    }
                    ctx.shadowBlur = 0;
                }

                update() {
                    if (this.unpossessTimer > 0) {
                        this.unpossessTimer--;
                        if (this.unpossessTimer <= 0) this.state = 'WISP';
                    }
                    if (this.dashCooldown > 0) this.dashCooldown--;

                    // (ìˆ˜ì •) ëŒì§„(DASHING) ìƒíƒœ
                    if (this.state === 'DASHING') {
                        if (!this.dashTarget || this.dashTarget.hp <= 0) { 
                            this.state = 'WISP';
                            this.dashTarget = null;
                            return;
                        }
                        
                        const dx = this.dashTarget.x - this.x;
                        const dy = this.dashTarget.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < this.radius + this.dashTarget.radius) {
                            // ë¹™ì˜ ì„±ê³µ
                            this.possess(this.dashTarget);
                        } else {
                            // ëŒì§„ ì´ë™
                            this.x += (dx / dist) * PLAYER_DASH_SPEED;
                            this.y += (dy / dist) * PLAYER_DASH_SPEED;
                        }
                        return; 
                    }

                    // ì´ë™ (WISP ë˜ëŠ” HOST)
                    const dx = targetPos.x - this.x;
                    const dy = targetPos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const currentSpeed = (this.state === 'HOST') ? this.speed : PLAYER_SPEED_WISP * this.stats.wispSpeedMult;
                    if (dist > currentSpeed) {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                    
                    if (this.state === 'HOST') {
                        this.gauge--;
                        gaugeBar.style.width = `${Math.max(0, (this.gauge / this.maxGauge) * 100)}%`;
                        if (this.gauge <= 0) this.unpossess();
                        
                        if(this.hostType === 'gargoyle' && this.isEliteHost && frameCount % 60 === 0) {
                            soulCore.heal(1); 
                        }
                        
                        this.attackTimer--;
                        if (this.attackTimer <= 0) this.attack();
                    }
                }
                
                attack() {
                    if (!this.hostType) return;
                    const props = MOB_PROPERTIES[this.hostType];
                    const attackCooldown = props.attackCooldown / (1.0 + this.stats.attackSpeedMult + this.stats.cooldownMult);
                    this.attackTimer = Math.max(10, attackCooldown); 
                    
                    const target = findNearestEnemy(this.x, this.y);
                    
                    const numProjectiles = 1 + this.stats.multiShot; // ì—˜ë¦¬íŠ¸ ë©€í‹°ìƒ·ì€ ë³„ë„
                    const isEliteMulti = this.isEliteHost && (this.hostType === 'skeleton' || this.hostType === 'bat' || this.hostType === 'imp');
                    const totalProjectiles = isEliteMulti ? numProjectiles + 2 : numProjectiles; // ì—˜ë¦¬íŠ¸ëŠ” +2
                    
                    const angleStep = 0.2; 
                    const startAngle = (target ? Math.atan2(target.y - this.y, target.x - this.x) : 0) - (angleStep * (totalProjectiles - 1)) / 2;

                    switch (this.hostType) {
                        case 'skeleton':
                        case 'bat':
                        case 'imp':
                        case 'slime':
                            if (target) {
                                let type, damage;
                                if(this.hostType === 'skeleton') { type = 'bone'; damage = this.stats.boneDamage; }
                                else if(this.hostType === 'bat') { type = 'sonic'; damage = this.stats.sonicDamage; }
                                else if(this.hostType === 'imp') { type = 'fireball'; damage = this.stats.fireballDamage; }
                                else if(this.hostType === 'slime') { type = 'slimeball'; damage = 1; }

                                for(let i=0; i<totalProjectiles; i++) {
                                    const currentAngle = startAngle + i * angleStep;
                                    projectiles.push(new Projectile(this.x, this.y, null, type, damage, { dx: Math.cos(currentAngle), dy: Math.sin(currentAngle) }, this.stats.slimeSlow));
                                }
                            }
                            break;
                        case 'zombie':
                            const auraRadius = 60 * this.stats.auraSizeMult * (this.isEliteHost ? 1.5 : 1);
                            particles.push(new Particle(this.x, this.y, 0, 0, 10, '#32CD32', 'aura', auraRadius));
                            enemies.forEach(enemy => {
                                if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < auraRadius) {
                                    enemy.takeDamage(1); 
                                }
                            });
                            break;
                        case 'gargoyle': 
                            const stompRadius = 105; 
                            particles.push(new Particle(this.x, this.y, 0, 0, 15, '#888888', 'shockwave', stompRadius));
                            enemies.forEach(enemy => {
                                if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < stompRadius) {
                                    enemy.takeDamage(2); 
                                }
                            });
                            break;
                    }
                }
                
                dash() {
                    if (this.dashCooldown > 0) return; 
                    
                    if (this.state === 'HOST') {
                        this.dashCooldown = 30; 
                        this.unpossess();
                    } else if (this.state === 'WISP') {
                        let closestEnemy = findNearestEnemy(this.x, this.y, 150); 
                        if (closestEnemy) {
                            this.state = 'DASHING';
                            this.dashTarget = closestEnemy;
                            this.dashCooldown = 60; 
                        }
                    }
                }

                possess(enemy) {
                    if (this.stats.jumpNova) {
                        projectiles.push(new Projectile(this.x, this.y, null, 'explosion', 5));
                    }
                    
                    particles.push(new Particle(this.x, this.y, 0, 0, 20, PLAYER_COLOR, 'shockwave'));
                    
                    this.state = 'HOST';
                    this.hostType = enemy.type;
                    this.isEliteHost = enemy.isElite; 
                    const props = MOB_PROPERTIES[this.hostType];
                    this.maxGauge = props.gauge * this.stats.maxGaugeMult;
                    this.gauge = this.maxGauge;
                    this.speed = props.speed;
                    this.x = enemy.x;
                    this.y = enemy.y;
                    targetPos.x = this.x; 
                    targetPos.y = this.y;
                    this.dashTarget = null;
                    
                    gaugeContainer.style.display = 'block';
                    enemies = enemies.filter(e => e !== enemy);
                }

                unpossess() {
                    this.state = 'UNPOSSESSING'; 
                    this.unpossessTimer = 90; 
                    this.hostType = null;
                    this.isEliteHost = false; 
                    this.gauge = 0;
                    gaugeContainer.style.display = 'none';
                }
                
                takeGaugeDamage(amount) {
                    if (this.state !== 'HOST') return;
                    this.gauge -= amount;
                }
                
                collectExp(value) {
                    if (gameState !== 'PLAYING') return; 
                    this.experience += value;
                    if (this.experience >= this.expToNextLevel) {
                        this.levelUp();
                    }
                    expBar.style.transform = `scaleX(${this.experience / this.expToNextLevel})`;
                }
                
                levelUp() {
                    gameState = 'PAUSED'; 
                    this.level++;
                    this.experience -= this.expToNextLevel; 
                    this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5);
                    
                    levelDisplay.textContent = `Lv. ${this.level}`;
                    expBar.style.transform = `scaleX(${Math.max(0, this.experience / this.expToNextLevel)})`;
                    
                    gameContainer.style.backgroundColor = '#FFFF00';
                    setTimeout(() => { gameContainer.style.backgroundColor = '#2a2a3e'; }, 100);
                    
                    currentUpgradeChoices = getRandomUpgrades(3);
                    for (let i = 0; i < 3; i++) {
                        upgradeCards[i].querySelector('h3').textContent = currentUpgradeChoices[i].title;
                        upgradeCards[i].querySelector('p').textContent = currentUpgradeChoices[i].desc;
                    }
                    levelUpOverlay.classList.add('visible');
                    infoButton.style.display = 'none'; 
                    
                    if (this.experience >= this.expToNextLevel) {
                        this.experience = this.expToNextLevel - 1; 
                    }
                }
            }
            
            class Enemy {
                constructor(x, y, type, isElite) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.isElite = isElite; 
                    this.props = MOB_PROPERTIES[type];
                    
                    // --- (ìƒˆë¡œìš´ HP ê³„ì‚° ë¡œì§) ---
                    // 1. ì‹œê°„ì— ë”°ë¥¸ ê¸°ë³¸ ë°°ìœ¨ (3ë¶„(180ì´ˆ)ë§ˆë‹¤ 50%ì”© ì¦ê°€)
                    const timeMultiplier = 1 + (gameTime / 180) * 0.5;
                    // 2. ê¸°ë³¸ HP (ì—˜ë¦¬íŠ¸ëŠ” 2ë°°)
                    let baseHp = this.props.hp * (isElite ? 2 : 1);
                    // 3. (ì¤‘ìš”) ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„°ì˜ ì´ˆë°˜ ì²´ë ¥ ë³´ë„ˆìŠ¤
                    const eliteFlatHpBoost = isElite ? 5 : 0; // (ìˆ˜ì •) 10 -> 5
                    
                    this.hp = Math.ceil((baseHp + eliteFlatHpBoost) * timeMultiplier);
                    // --- (ì—¬ê¸°ê¹Œì§€) ---
                    
                    this.radius = 8 * PIXEL_SCALE * (isElite ? 1.5 : 1); 
                    this.color = this.props.color;
                    this.sprite = this.props.sprite;
                    this.speed = this.props.speed;
                    this.hitTimer = 0; 
                }
                draw() {
                    let drawColor = this.color;
                    if (this.hitTimer > 0) {
                        this.hitTimer--;
                        drawColor = '#FFFFFF'; 
                    }
                    
                    ctx.shadowColor = this.isElite ? ELITE_COLOR : this.color;
                    ctx.shadowBlur = this.isElite ? 15 : 10;
                    drawPixelSprite(this.sprite, this.x, this.y, drawColor, this.isElite);
                    ctx.shadowBlur = 0;
                }
                update() {
                    let target = soulCore;
                    const distToCore = Math.hypot(soulCore.x - this.x, soulCore.y - this.y);
                    
                    if (player.state === 'HOST') {
                        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                        if (distToPlayer < distToCore) {
                            target = player;
                        }
                    }

                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > this.radius + target.radius) { 
                        this.x += dx / dist * this.speed * 0.5; 
                        this.y += dy / dist * this.speed * 0.5;
                    }
                }
                takeDamage(amount) {
                    this.hp -= amount;
                    this.hitTimer = 5; 
                    if (this.hp <= 0) {
                        this.die();
                    }
                }
                die(giveExp = true) { 
                    if (giveExp) {
                        const exp = this.props.exp * (this.isElite ? 3 : 1); 
                        echoes.push(new Echo(this.x, this.y, exp));
                    }
                    for(let i=0; i < 5; i++) {
                        particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*3, (Math.random()-0.5)*3, 30, this.color, 'pixel'));
                    }
                    enemies = enemies.filter(e => e !== this);
                }
            }
            
            class Projectile {
                constructor(x, y, target, type, damage, direction = null, slow = false) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.damage = damage;
                    this.slow = slow; 
                    this.radius = 2 * PIXEL_SCALE;
                    this.speed = 5;
                    this.life = 60; 
                    this.pierceCount = player.stats.pierce; 
                    
                    if (type === 'sonic') this.speed = 8;
                    if (type === 'slimeball') this.speed = 3;
                    if (type === 'fireball') {
                        this.speed = 4;
                        this.damage = damage;
                    }
                    
                    if (direction) { 
                        this.dx = direction.dx * this.speed;
                        this.dy = direction.dy * this.speed;
                    } else if (type === 'explosion') {
                        this.radius = 50;
                        this.life = 10; 
                        this.dx = 0; this.dy = 0;
                        this.hitEnemies = []; 
                    } else if (target) {
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        this.dx = (dx / dist) * this.speed;
                        this.dy = (dy / dist) * this.speed;
                    } else {
                        this.dx = 0; this.dy = 0; 
                        this.life = 0; 
                    }
                }
                draw() {
                    ctx.shadowBlur = 5;
                    switch(this.type) {
                        case 'bone':
                            ctx.fillStyle = '#FFFFFF';
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillRect(this.x - 2, this.y - 4, 4, 8); 
                            break;
                        case 'sonic':
                            ctx.fillStyle = '#9400D3';
                            ctx.shadowColor = '#9400D3';
                            ctx.fillRect(this.x - 4, this.y - 1, 8, 2); 
                            break;
                        case 'slimeball': 
                            ctx.fillStyle = '#ADFF2F';
                            ctx.shadowColor = '#ADFF2F';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 3 * PIXEL_SCALE, 0, Math.PI*2);
                            ctx.fill();
                            break;
                        case 'fireball': 
                            ctx.fillStyle = '#FF4500';
                            ctx.shadowColor = '#FF4500';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 4 * PIXEL_SCALE, 0, Math.PI*2);
                            ctx.fill();
                            break;
                        case 'explosion':
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius * (1 - this.life/10), 0, Math.PI*2);
                            ctx.stroke();
                            break;
                    }
                    ctx.shadowBlur = 0;
                }
                update() {
                    this.life--;
                    if (this.type !== 'explosion') {
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }
            
            class Echo { // ê²½í—˜ì¹˜
                constructor(x, y, value) {
                    this.x = x;
                    this.y = y;
                    this.value = value;
                    this.radius = 2 * PIXEL_SCALE; // (ìˆ˜ì •) 3 -> 2
                    this.color = '#FFFF00'; 
                    this.pickupRadius = 120; // (ìˆ˜ì •) 60 -> 120
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                update() {
                    // (ìˆ˜ì •) 'ìœ ë ¹' ìƒíƒœì¼ ë•Œë§Œ ëŒì–´ë‹¹ê¹€
                    if (player.state === 'WISP' || player.state === 'UNPOSSESSING') {
                        const dist = Math.hypot(player.x - this.x, player.y - this.y);
                        if (dist < this.pickupRadius) {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            this.x += dx * 0.1;
                            this.y += dy * 0.1;
                        }
                    }
                }
            }
            
            // íŒŒí‹°í´ í´ë˜ìŠ¤
            class Particle {
                constructor(x, y, dx, dy, life, color, type, radius = 0) {
                    this.x = x;
                    this.y = y;
                    this.dx = dx;
                    this.dy = dy;
                    this.life = life;
                    this.color = color;
                    this.type = type;
                    this.initialLife = life;
                    this.radius = radius;
                }
                draw() {
                    ctx.globalAlpha = this.life / this.initialLife; 
                    if (this.type === 'pixel') {
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, PIXEL_SCALE, PIXEL_SCALE);
                    } else if (this.type === 'shockwave') {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, (this.type === 'stomp' ? this.radius : 20) + (this.initialLife - this.life), 0, Math.PI*2);
                        ctx.stroke();
                    } else if (this.type === 'aura') {
                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = 0.2; 
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                        ctx.fill();
                    } else if (this.type === 'trail') {
                         ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.life / 5, 0, Math.PI*2); 
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                }
                update() {
                    this.life--;
                    if(this.type === 'pixel') {
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            
            startButton.addEventListener('click', handleStartButton);
            infoButton.addEventListener('click', () => {
                if (gameState === 'PLAYING' || gameState === 'PAUSED') return;
                if (gameOverlay.dataset.mode === 'info') setupStartScreen();
                else showInfo();
            });
            
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.clientX - rect.left;
                targetPos.y = e.clientY - rect.top;
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.touches[0].clientX - rect.left;
                targetPos.y = e.touches[0].clientY - rect.top;
            }, { passive: false });
            
            canvas.addEventListener('mousedown', e => {
                if (gameState === 'PLAYING') player.dash();
            });
            canvas.addEventListener('touchstart', e => {
                if (e.target === canvas && gameState === 'PLAYING') {
                    player.dash();
                }
            }, { passive: false });
            
            upgradeCards.forEach((card, index) => {
                card.addEventListener('click', () => {
                    if (gameState !== 'PAUSED') return;
                    currentUpgradeChoices[index].apply();
                    gameState = 'PLAYING';
                    levelUpOverlay.classList.remove('visible');
                    infoButton.style.display = 'none'; 
                    gameLoop(); 
                });
            });


            // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
            function findNearestEnemy(x, y, maxDist = Infinity) {
                let closestEnemy = null;
                let minDist = maxDist;
                enemies.forEach(enemy => {
                    const dist = Math.hypot(x - enemy.x, y - enemy.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestEnemy = enemy;
                    }
                });
                return closestEnemy;
            }
            
            function getRandomUpgrades(num) {
                const shuffled = [...UPGRADE_POOL].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, num);
            }
            
            function getBestTime() {
                return parseInt(localStorage.getItem(BEST_TIME_KEY) || '0');
            }
            
            function saveBestTime(time) {
                const currentBest = getBestTime();
                if (time > currentBest) {
                    localStorage.setItem(BEST_TIME_KEY, time);
                    return true;
                }
                return false;
            }
            
            const SOUL_CORE_SPRITE = ['00100','01110','11111','01110','00100'];
            const SOUL_CORE_COLOR = '#FF00FF';
            function drawSoulCore() {
                ctx.shadowColor = SOUL_CORE_COLOR;
                ctx.shadowBlur = 15;
                drawPixelSprite(SOUL_CORE_SPRITE, soulCore.x, soulCore.y, SOUL_CORE_COLOR, true); 
                ctx.shadowBlur = 0;
            }
            function updateCoreHpBar() {
                coreHpBar.style.width = `${Math.max(0, (soulCore.hp / soulCore.maxHp) * 100)}%`;
            }

            // --- í•µì‹¬ í•¨ìˆ˜ ---

            function handleStartButton() {
                if (gameOverlay.dataset.mode === 'info') setupStartScreen();
                else startGame();
            }
            
            function setupStartScreen(isGameOver = false) {
                gameState = 'START';
                bestTimeDisplay.textContent = `Best Time: ${getBestTime()}s`;
                
                if (isGameOver) {
                    finalScoreDisplay.textContent = `Time Survived: ${gameTime}s`;
                    if (saveBestTime(gameTime)) {
                        finalScoreDisplay.textContent += " (New Record!)";
                        bestTimeDisplay.textContent = `BestTime: ${gameTime}s`;
                    }
                    finalScoreDisplay.style.display = 'block';
                    startButton.textContent = 'ë‹¤ì‹œí•˜ê¸°';
                } else {
                    finalScoreDisplay.style.display = 'none';
                    startButton.textContent = 'ì‹œì‘í•˜ê¸°';
                }
                
                instructions.style.display = 'none';
                overlayMessage.style.display = 'block';
                gameOverlay.dataset.mode = 'start';
                gameOverlay.classList.add('visible');
                infoButton.style.display = 'block'; 
            }
            
            function showInfo() {
                gameOverlay.dataset.mode = 'info';
                instructions.style.display = 'block'; 
                overlayMessage.style.display = 'none'; 
                finalScoreDisplay.style.display = 'none';
                startButton.textContent = 'ëŒì•„ê°€ê¸°';
                setTimeout(() => { instructions.scrollTop = 0; }, 0); 
            }

            function startGame() {
                gameTime = 0;
                frameCount = 0;
                waveCount = 1;
                spawnInterval = 180; 
                nextSpawnFrame = 0;
                
                timeDisplay.textContent = `Time: 0`;
                
                player = new Player();
                levelDisplay.textContent = `Lv. ${player.level}`;
                expBar.style.transform = `scaleX(0)`;
                
                soulCore = { 
                    x: VIEWPORT_WIDTH / 2, 
                    y: VIEWPORT_HEIGHT / 2, 
                    radius: 10 * PIXEL_SCALE, 
                    hp: 150, // (ìˆ˜ì •) 100 -> 150
                    maxHp: 150, // (ìˆ˜ì •) 100 -> 150
                    heal(amount) {
                        this.hp = Math.min(this.maxHp, this.hp + amount);
                        updateCoreHpBar();
                    }
                };
                updateCoreHpBar();
                
                enemies = [];
                projectiles = [];
                echoes = [];
                particles = [];

                gameState = 'PLAYING';
                gameOverlay.classList.remove('visible');
                infoButton.style.display = 'none'; 
                
                clearInterval(gameTimerInterval);
                gameTimerInterval = setInterval(() => {
                    if (gameState === 'PLAYING') {
                        gameTime++;
                        timeDisplay.textContent = `Time: ${gameTime}`;
                    }
                }, 1000);
                
                gameLoop(); 
            }

            function endGame() {
                gameState = 'OVER';
                clearInterval(gameTimerInterval); 
                cancelAnimationFrame(gameLoopId);
                setupStartScreen(true); 
            }
            
            function spawnEnemies() {
                frameCount++;
                if (frameCount < 180) return; // 3ì´ˆê°„ ëŒ€ê¸°
                
                if (frameCount > nextSpawnFrame) {
                    for(let i=0; i < waveCount; i++) {
                        const x = Math.random() < 0.5 ? -20 : VIEWPORT_WIDTH + 20;
                        const y = Math.random() * VIEWPORT_HEIGHT;
                        const type = MOB_TYPES[Math.floor(Math.random() * MOB_TYPES.length)];
                        const isElite = Math.random() < eliteSpawnChance; 
                        enemies.push(new Enemy(x, y, type, isElite));
                    }
                    nextSpawnFrame = frameCount + spawnInterval;
                }
                
                // 30ì´ˆë§ˆë‹¤ ë‚œì´ë„ ìƒìŠ¹ (ìˆ˜ì •)
                if (frameCount % 1800 === 0 && frameCount > 0) { 
                    spawnInterval = Math.max(30, spawnInterval * 0.9); 
                    waveCount = Math.min(10, waveCount + 1); 
                }
            }
            
            function checkCollisions() {
                // 1. ìœ ë ¹/ëŒì§„ vs ì  -> ì¶©ëŒ ì—†ìŒ (ë¬´ì )
                
                // 2. ìˆ™ì£¼ + ì  -> ê²Œì´ì§€ ëŒ€ë¯¸ì§€
                if (player.state === 'HOST') {
                    for (const enemy of enemies) {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                            player.takeGaugeDamage(50); 
                        }
                    }
                }
                
                // 3. ì  + ì˜í˜¼ í•µ
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    if (Math.hypot(e.x - soulCore.x, e.y - soulCore.y) < e.radius + soulCore.radius) {
                        soulCore.hp -= e.props.hp; 
                        updateCoreHpBar();
                        e.die(false); 
                        
                        if (soulCore.hp <= 0) {
                            endGame();
                            return;
                        }
                    }
                }
                
                // 4. íˆ¬ì‚¬ì²´ + ì  (ìˆ˜ì •ë¨)
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    
                    if (p.type === 'explosion') {
                        if (!p.hitEnemies) p.hitEnemies = []; // í­ë°œì€ 1íšŒë§Œ íˆíŠ¸
                        for (const e of enemies) {
                            if (!p.hitEnemies.includes(e) && Math.hypot(p.x - e.x, p.y - e.y) < p.radius) {
                                e.takeDamage(p.damage);
                                p.hitEnemies.push(e); 
                            }
                        }
                        continue; 
                    }

                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (Math.hypot(p.x - e.x, p.y - e.y) < e.radius) {
                            e.takeDamage(p.damage);
                            if (p.slow) e.slowTimer = 60; // 1ì´ˆ ìŠ¬ë¡œìš°
                            
                            // ì„í”„ íŒŒì´ì–´ë³¼ ì ì¤‘ ì‹œ í­ë°œ
                            if (p.type === 'fireball') {
                                projectiles.push(new Projectile(p.x, p.y, null, 'explosion', Math.floor(p.damage / 2)));
                            }
                            
                            p.pierceCount--; // ê´€í†µ
                            if (p.pierceCount < 0) {
                                projectiles.splice(i, 1);
                                break; // ì´ íˆ¬ì‚¬ì²´ëŠ” ì†Œë©¸
                            }
                        }
                    }
                }
                
                // 5. í”Œë ˆì´ì–´ + ì—ì½” (ìˆ˜ì •ë¨)
                for (let i = echoes.length - 1; i >= 0; i--) {
                    const e = echoes[i];
                    // (ìˆ˜ì •) ìœ ë ¹ ìƒíƒœì¼ ë•Œë§Œ ê²½í—˜ì¹˜ íšë“
                    if ((player.state === 'WISP' || player.state === 'UNPOSSESSING') &&
                        Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius + 30) 
                    {
                        player.collectExp(e.value);
                        echoes.splice(i, 1);
                    }
                }
            }

            // --- ë©”ì¸ ê²Œì„ ë£¨í”„ ---
            function gameLoop() {
                if (gameState !== 'PLAYING') {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                gameLoopId = requestAnimationFrame(gameLoop);

                // 1. í´ë¦¬ì–´
                ctx.fillStyle = "#2a2a3e";
                ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
                
                // 2. ìƒì„±
                spawnEnemies();
                
                // 3. ì—…ë°ì´íŠ¸
                player.update();
                enemies.forEach(e => e.update());
                projectiles.forEach(p => p.update());
                echoes.forEach(e => e.update());
                particles.forEach(p => p.update());
                
                // 4. ì¶©ëŒ
                checkCollisions();
                
                // 5. ê·¸ë¦¬ê¸°
                drawSoulCore(); 
                projectiles.forEach(p => p.draw());
                echoes.forEach(e => e.draw());
                enemies.forEach(e => e.draw());
                player.draw(); 
                particles.forEach(p => p.draw());
                
                // 6. ì œê±° (ìˆ˜ëª… ë‹¤í•œ ê°ì²´ë“¤)
                projectiles = projectiles.filter(p => p.life > 0);
                particles = particles.filter(p => p.life > 0);
            }
            
            // ì´ˆê¸° í™”ë©´ ì„¤ì •
            setupStartScreen();
        });
    </script>

</body>
</html>
