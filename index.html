<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ‘» ì—ì½” ì í¼ (v4.0 - ëª¹ ë³µì›)</title>
    <style>
        /* --- ê¸°ë³¸ ë° ë ˆì´ì•„ì›ƒ --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #000; /* ê²€ì€ìƒ‰ ë°°ê²½ */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'DotGothic16', 'Courier New', monospace; /* í”½ì…€ í°íŠ¸ */
            touch-action: none; 
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 800px;
            overflow: hidden;
            background-color: #2a2a3e; /* ë¬˜ì§€ ë°°ê²½ìƒ‰ */
            border: 2px solid #50507a;
        }

        #game-canvas {
            display: block;
            cursor: none;
            /* í”½ì…€ì´ íë¦¿í•´ì§€ëŠ” ê²ƒ ë°©ì§€ */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        /* --- UI ì˜ì—­ --- */
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        
        #gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 0; /* í”½ì…€ ìŠ¤íƒ€ì¼ */
            overflow: hidden;
            display: none; 
        }

        #gauge-bar {
            width: 100%;
            height: 100%;
            background-color: #00FFFF; /* ì‹œì•ˆìƒ‰ */
            transition: width 0.1s linear;
        }

        #top-ui {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px #000;
            z-index: 5;
            pointer-events: none; 
        }
        
        /* ê²½í—˜ì¹˜ ë°” */
        #exp-bar {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 5px;
            background-color: #FFFF00; /* ë…¸ë€ìƒ‰ */
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.2s ease;
            z-index: 6;
        }

        /* --- ì˜¤ë²„ë ˆì´ ê³µí†µ --- */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease, visibility 0.3s;
            visibility: hidden;
            opacity: 0;
            z-index: 10;
        }

        .overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        /* --- ì‹œì‘/ì¢…ë£Œ ì˜¤ë²„ë ˆì´ --- */
        #game-overlay h1 {
            color: #00FFFF; /* ë„¤ì˜¨ ì‹œì•ˆ */
            margin-bottom: 10px;
        }

        #game-overlay p {
            font-size: 1.1em;
            margin: 10px 20px;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #1a1a2e;
            background-color: #00FFFF;
            border: 2px solid #fff;
            border-radius: 0; /* í”½ì…€ ìŠ¤íƒ€ì¼ */
            cursor: pointer;
            box-shadow: 0 0 20px #00FFFF;
            margin-top: 20px;
        }

        #final-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #FF00FF; /* ë„¤ì˜¨ ë§ˆì  íƒ€ */
            margin: 10px 0;
        }
        
        /* --- ë ˆë²¨ ì—… ì˜¤ë²„ë ˆì´ (ìƒˆë¡œ ì¶”ê°€) --- */
        #level-up-overlay {
            justify-content: center;
            gap: 20px;
        }
        
        #level-up-title {
            color: #FFFF00;
            font-size: 2em;
            text-shadow: 2px 2px #000;
        }
        
        .upgrade-card {
            width: 80%;
            max-width: 300px;
            background-color: #1a1a2e;
            border: 3px solid #00FFFF;
            padding: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .upgrade-card:hover {
            background-color: #3a3a5e;
        }
        
        .upgrade-card h3 {
            margin: 0 0 10px 0;
            color: #FFFF00;
        }
        
        .upgrade-card p {
            margin: 0;
            font-size: 1em;
            color: #eee;
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        
        <div id="top-ui">
            <div id="score">Score: 0</div>
            <div id="level">Lv. 1</div>
        </div>
        
        <div id="exp-bar"></div> <canvas id="game-canvas"></canvas>

        <div id="ui-container">
            <div id="gauge-container">
                <div id="gauge-bar"></div>
            </div>
        </div>
        
        <div id="game-overlay" class="overlay visible">
            <div id="overlay-content-wrapper">
                <h1>ğŸ‘» ì—ì½” ì í¼ ğŸ‘»</h1>
                <p id="overlay-message">
                    ì ì˜ ëª¸ì„ ë¹¼ì•—ì•„ ì‹¸ìš°ì„¸ìš”!<br>
                    ìˆ™ì£¼ê°€ íŒŒê´´ë˜ê¸° ì „ì— ë‹¤ìŒ ì ìœ¼ë¡œ 'ì í”„'í•˜ì„¸ìš”.
                </p>
                <p id="final-score"></p>
                <button id="start-button">ì‹œì‘í•˜ê¸°</button>
            </div>
        </div>
        
        <div id="level-up-overlay" class="overlay">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <div class="upgrade-card" data-upgrade="0">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="1">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="2">
                <h3></h3>
                <p></p>
            </div>
        </div>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- DOM ìš”ì†Œ ---
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const gameOverlay = document.getElementById('game-overlay');
            const startButton = document.getElementById('start-button');
            const finalScoreDisplay = document.getElementById('final-score');
            
            const scoreDisplay = document.getElementById('score');
            const levelDisplay = document.getElementById('level');
            const expBar = document.getElementById('exp-bar');
            const gaugeContainer = document.getElementById('gauge-container');
            const gaugeBar = document.getElementById('gauge-bar');
            
            const levelUpOverlay = document.getElementById('level-up-overlay');
            const upgradeCards = document.querySelectorAll('.upgrade-card');

            // --- ìº”ë²„ìŠ¤ í¬ê¸° ---
            const VIEWPORT_WIDTH = gameContainer.clientWidth;
            const VIEWPORT_HEIGHT = gameContainer.clientHeight;
            const PIXEL_SCALE = 2; // í”½ì…€ ì•„íŠ¸ìš© ìŠ¤ì¼€ì¼
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;
            ctx.imageSmoothingEnabled = false;

            // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
            let gameState = 'START'; // 'START', 'PLAYING', 'PAUSED', 'OVER'
            let score = 0;
            let gameLoopId = null;
            let frameCount = 0;
            
            let spawnInterval = 180; // 3ì´ˆ
            let nextSpawnFrame = spawnInterval;
            let waveCount = 1;

            let player, enemies, projectiles, echoes;

            // --- ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜ ---
            let targetPos = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2 };

            // --- ëª¬ìŠ¤í„°/í”Œë ˆì´ì–´/ì—…ê·¸ë ˆì´ë“œ ì •ì˜ (ìˆ˜ì •ë¨) ---
            const PLAYER_COLOR = '#00FFFF';
            const PLAYER_RADIUS = 4 * PIXEL_SCALE; // 8px
            const PLAYER_SPEED_WISP = 2.5;

            const MOB_PROPERTIES = {
                'skeleton': { gauge: 1000, attackType: 'bone', attackCooldown: 60, speed: 1.5, hp: 2, exp: 10, 
                    sprite: ['0110','1111','0110','0110','1001'], color: '#FFFFFF' },
                'zombie': { gauge: 1800, attackType: 'aura', attackCooldown: 10, speed: 0.8, hp: 5, exp: 20,
                    sprite: ['0110','1111','0110','1111','1001'], color: '#32CD32' },
                'bat': { gauge: 600, attackType: 'sonic', attackCooldown: 40, speed: 2.5, hp: 1, exp: 10, 
                    sprite: ['10101','01110','00100'], color: '#9400D3' }, // 5x3 í”½ì…€
                'gargoyle': { gauge: 4000, attackType: 'none', attackCooldown: 999, speed: 0.5, hp: 10, exp: 30,
                    sprite: ['01110','11111','11011','01110','01010'], color: '#888888' } // 5x5 í”½ì…€
            };
            const MOB_TYPES = Object.keys(MOB_PROPERTIES);
            
            // ì—…ê·¸ë ˆì´ë“œ í’€ (ìˆ˜ì •ë¨)
            const UPGRADE_POOL = [
                { id: 'gauge_1', title: 'ìˆ™ì£¼ ì•ˆì •í™” I', desc: 'ë¹™ì˜ ê²Œì´ì§€ ì´ëŸ‰ì´ 15% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.maxGaugeMult += 0.15 },
                { id: 'wisp_speed_1', title: 'ìœ ë ¹ ê¸°ë™ë ¥ I', desc: 'ìœ ë ¹ ìƒíƒœì˜ ì´ë™ ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.wispSpeedMult += 0.1 },
                { id: 'jump_nova', title: 'ì†Œìš¸ ë…¸ë°”', desc: 'ìƒˆë¡œìš´ ìˆ™ì£¼ë¡œ \'ì í”„\'í•  ë•Œ ì£¼ë³€ì— í­ë°œì„ ì¼ìœ¼í‚µë‹ˆë‹¤.', apply: () => player.stats.jumpNova = true },
                { id: 'attack_speed_1', title: 'ê³µê²© ì†ë„ I', desc: 'ìˆ™ì£¼ì˜ ê³µê²© ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.attackSpeedMult += 0.1 },
                { id: 'aura_size_1', title: 'ë¶€íŒ¨ ì˜¤ë¼ í™•ì¥ I', desc: 'ì¢€ë¹„ì˜ ì˜¤ë¼ ë²”ìœ„ê°€ 15% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.auraSizeMult += 0.15 },
                { id: 'bone_damage_1', title: 'ë‚ ì¹´ë¡œìš´ ë¼ˆ I', desc: 'ìŠ¤ì¼ˆë ˆí†¤ì˜ ë¼ˆ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.boneDamage += 1 },
                { id: 'sonic_damage_1', title: 'ì´ˆìŒíŒŒ ê°•í™” I', desc: 'ë°•ì¥ì˜ ì´ˆìŒíŒŒ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.sonicDamage += 1 },
                { id: 'gargoyle_gauge_1', title: 'ì„í™” í”¼ë¶€ ê°•í™” I', desc: 'ê°€ê³ ì¼ì˜ ë¹™ì˜ ê²Œì´ì§€ê°€ 20% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.maxGaugeMult += 0.2 },
            ];
            let currentUpgradeChoices = [];

            // --- í”½ì…€ ì•„íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
            function drawPixelSprite(spriteData, x, y, colorTint) {
                const spriteHeight = spriteData.length;
                const spriteWidth = spriteData[0].length;
                
                const startX = Math.floor(x - (spriteWidth * PIXEL_SCALE) / 2);
                const startY = Math.floor(y - (spriteHeight * PIXEL_SCALE) / 2);

                ctx.fillStyle = colorTint;
                
                for (let r = 0; r < spriteHeight; r++) {
                    for (let c = 0; c < spriteWidth; c++) {
                        if (spriteData[r][c] === '1') {
                            ctx.fillRect(startX + c * PIXEL_SCALE, startY + r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                        }
                    }
                }
            }
            
            // --- í´ë˜ìŠ¤ ì •ì˜ ---

            class Player {
                constructor() { this.reset(); }
                reset() {
                    this.x = VIEWPORT_WIDTH / 2;
                    this.y = VIEWPORT_HEIGHT / 2;
                    this.radius = PLAYER_RADIUS;
                    this.state = 'WISP'; 
                    this.hostType = null;
                    this.gauge = 0;
                    this.maxGauge = 0;
                    this.speed = PLAYER_SPEED_WISP;
                    this.attackTimer = 0;
                    this.dashCooldown = 0;
                    this.unpossessTimer = 0;
                    
                    this.level = 1;
                    this.experience = 0;
                    this.expToNextLevel = 100;
                    
                    // ì—…ê·¸ë ˆì´ë“œ ìŠ¤íƒ¯
                    this.stats = {
                        maxGaugeMult: 1.0,
                        wispSpeedMult: 1.0,
                        attackSpeedMult: 1.0,
                        jumpNova: false,
                        auraSizeMult: 1.0,
                        boneDamage: 1,
                        sonicDamage: 1, // (ìƒˆë¡œ ì¶”ê°€)
                    };
                }

                draw() {
                    ctx.shadowBlur = 10; 
                    if (this.state === 'WISP' || this.state === 'UNPOSSESSING') {
                        ctx.fillStyle = PLAYER_COLOR;
                        ctx.shadowColor = PLAYER_COLOR;
                        if(this.unpossessTimer > 0 && frameCount % 10 < 5) {
                             ctx.globalAlpha = 0.5; // ë¬´ì  ê¹œë¹¡ì„
                        }
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    } else if (this.state === 'HOST') {
                        const spriteData = MOB_PROPERTIES[this.hostType].sprite;
                        drawPixelSprite(spriteData, this.x, this.y, PLAYER_COLOR);
                    }
                    ctx.shadowBlur = 0;
                }

                update() {
                    if (this.unpossessTimer > 0) {
                        this.unpossessTimer--;
                        if (this.unpossessTimer <= 0) this.state = 'WISP';
                    }
                    if (this.dashCooldown > 0) this.dashCooldown--;

                    // ì´ë™
                    const dx = targetPos.x - this.x;
                    const dy = targetPos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const currentSpeed = (this.state === 'HOST') ? this.speed : PLAYER_SPEED_WISP * this.stats.wispSpeedMult;
                    if (dist > currentSpeed) {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                    
                    if (this.state === 'HOST') {
                        this.gauge--;
                        gaugeBar.style.width = `${Math.max(0, (this.gauge / this.maxGauge) * 100)}%`;
                        if (this.gauge <= 0) this.unpossess();
                        
                        this.attackTimer--;
                        if (this.attackTimer <= 0) this.attack();
                    }
                }
                
                attack() {
                    if (!this.hostType) return;
                    const props = MOB_PROPERTIES[this.hostType];
                    const attackCooldown = props.attackCooldown / (1.0 + this.stats.attackSpeedMult);
                    this.attackTimer = Math.max(10, attackCooldown); 
                    
                    const target = findNearestEnemy(this.x, this.y);
                    
                    switch (this.hostType) {
                        case 'skeleton':
                            if (target) {
                                projectiles.push(new Projectile(this.x, this.y, target, 'bone', this.stats.boneDamage));
                            }
                            break;
                        case 'zombie':
                            const auraRadius = 60 * this.stats.auraSizeMult;
                            enemies.forEach(enemy => {
                                if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < auraRadius) {
                                    enemy.takeDamage(1); // ì˜¤ë¼ ë°ë¯¸ì§€ëŠ” 1 ê³ ì •
                                }
                            });
                            break;
                        case 'bat': // (ìƒˆë¡œ ì¶”ê°€)
                            if (target) {
                                projectiles.push(new Projectile(this.x, this.y, target, 'sonic', this.stats.sonicDamage));
                            }
                            break;
                    }
                }
                
                dash() {
                    if (this.dashCooldown > 0 || this.state === 'HOST') return; 
                    this.dashCooldown = 30; 
                    
                    let closestEnemy = findNearestEnemy(this.x, this.y, 150); // 150px ë²”ìœ„ ë‚´
                    
                    if (closestEnemy) {
                        this.possess(closestEnemy);
                    }
                }

                possess(enemy) {
                    if (this.stats.jumpNova) {
                        // ì í”„ ë…¸ë°” (ì£¼ë³€ ì  ë°ë¯¸ì§€)
                        projectiles.push(new Projectile(this.x, this.y, null, 'explosion', 5));
                    }
                    
                    this.state = 'HOST';
                    this.hostType = enemy.type;
                    const props = MOB_PROPERTIES[this.hostType];
                    this.maxGauge = props.gauge * this.stats.maxGaugeMult;
                    this.gauge = this.maxGauge;
                    this.speed = props.speed;
                    this.x = enemy.x;
                    this.y = enemy.y;
                    targetPos.x = this.x; 
                    targetPos.y = this.y;
                    
                    gaugeContainer.style.display = 'block';
                    enemies = enemies.filter(e => e !== enemy);
                }

                unpossess() {
                    this.state = 'UNPOSSESSING'; 
                    this.unpossessTimer = 90; // 1.5ì´ˆ ë¬´ì 
                    this.hostType = null;
                    this.gauge = 0;
                    gaugeContainer.style.display = 'none';
                }
                
                collectExp(value) {
                    if (gameState !== 'PLAYING') return; // ë ˆë²¨ì—… ì¤‘ ê²½í—˜ì¹˜ íšë“ ë°©ì§€
                    this.experience += value;
                    if (this.experience >= this.expToNextLevel) {
                        this.levelUp();
                    }
                    expBar.style.transform = `scaleX(${this.experience / this.expToNextLevel})`;
                }
                
                levelUp() {
                    gameState = 'PAUSED'; 
                    this.level++;
                    this.experience -= this.expToNextLevel; // ë‚¨ì€ ê²½í—˜ì¹˜ ì´ì›”
                    this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5);
                    
                    levelDisplay.textContent = `Lv. ${this.level}`;
                    expBar.style.transform = `scaleX(${Math.max(0, this.experience / this.expToNextLevel)})`;
                    
                    currentUpgradeChoices = getRandomUpgrades(3);
                    for (let i = 0; i < 3; i++) {
                        upgradeCards[i].querySelector('h3').textContent = currentUpgradeChoices[i].title;
                        upgradeCards[i].querySelector('p').textContent = currentUpgradeChoices[i].desc;
                    }
                    levelUpOverlay.classList.add('visible');
                    
                    // ë ˆë²¨ì´ ë” ì˜¤ë¥¼ ìˆ˜ ìˆìœ¼ë©´
                    if (this.experience >= this.expToNextLevel) {
                        // (ê°„ë‹¨í™”) ì—¬ê¸°ì„œëŠ” 1ë ˆë²¨ì—…ë§Œ ì²˜ë¦¬
                        this.experience = this.expToNextLevel - 1; 
                    }
                }
            }
            
            class Enemy {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.props = MOB_PROPERTIES[type];
                    this.hp = this.props.hp;
                    this.radius = 8 * PIXEL_SCALE; 
                    this.color = this.props.color;
                    this.sprite = this.props.sprite;
                    this.speed = this.props.speed;
                }
                draw() {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    drawPixelSprite(this.sprite, this.x, this.y, this.color);
                    ctx.shadowBlur = 0;
                }
                update() {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > this.radius) { 
                        this.x += dx / dist * this.speed * 0.5; 
                        this.y += dy / dist * this.speed * 0.5;
                    }
                }
                takeDamage(amount) {
                    this.hp -= amount;
                    if (this.hp <= 0) {
                        this.die();
                    }
                }
                die() {
                    score += this.props.exp; 
                    scoreDisplay.textContent = `Score: ${score}`;
                    echoes.push(new Echo(this.x, this.y, this.props.exp));
                    enemies = enemies.filter(e => e !== this);
                }
            }
            
            class Projectile {
                constructor(x, y, target, type, damage) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.damage = damage;
                    this.radius = 2 * PIXEL_SCALE;
                    this.speed = (type === 'sonic') ? 8 : 5;
                    this.life = 60; // 1ì´ˆ ìˆ˜ëª…
                    
                    if (type === 'explosion') {
                        this.radius = 50;
                        this.life = 10; // 0.16ì´ˆ
                    } else if (target) {
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        this.dx = (dx / dist) * this.speed;
                        this.dy = (dy / dist) * this.speed;
                    } else { // íƒ€ê²Ÿì´ ì—†ìœ¼ë©´ (ì˜ˆ: ì í”„ ë…¸ë°”)
                        this.dx = 0; this.dy = 0; 
                    }
                }
                draw() {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.shadowColor = '#FFFFFF';
                    ctx.shadowBlur = 5;
                    switch(this.type) {
                        case 'bone':
                            ctx.fillRect(this.x - 2, this.y - 4, 4, 8); // 2x4 í”½ì…€
                            break;
                        case 'sonic':
                            ctx.fillRect(this.x - 4, this.y - 1, 8, 2); // 4x1 í”½ì…€
                            break;
                        case 'explosion':
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius * (1 - this.life/10), 0, Math.PI*2);
                            ctx.stroke();
                            break;
                    }
                    ctx.shadowBlur = 0;
                }
                update() {
                    this.life--;
                    if (this.type !== 'explosion') {
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }
            
            class Echo { // ê²½í—˜ì¹˜
                constructor(x, y, value) {
                    this.x = x;
                    this.y = y;
                    this.value = value;
                    this.radius = 3 * PIXEL_SCALE;
                    this.color = '#FFFF00'; // ë…¸ë€ìƒ‰
                    this.pickupRadius = 60;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                update() {
                    // í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ëŒì–´ë‹¹ê²¨ì§
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (dist < this.pickupRadius) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        this.x += dx * 0.1;
                        this.y += dy * 0.1;
                    }
                }
            }

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            
            startButton.addEventListener('click', startGame);
            
            // ì´ë™
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.clientX - rect.left;
                targetPos.y = e.clientY - rect.top;
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.touches[0].clientX - rect.left;
                targetPos.y = e.touches[0].clientY - rect.top;
            }, { passive: false });
            
            // ëŒ€ì‹œ/ë¹™ì˜
            canvas.addEventListener('mousedown', e => {
                if (gameState === 'PLAYING') player.dash();
            });
            canvas.addEventListener('touchstart', e => {
                if (e.target === canvas && gameState === 'PLAYING') {
                    player.dash();
                }
            }, { passive: false });
            
            // ì—…ê·¸ë ˆì´ë“œ ì¹´ë“œ í´ë¦­
            upgradeCards.forEach((card, index) => {
                card.addEventListener('click', () => {
                    if (gameState !== 'PAUSED') return;
                    currentUpgradeChoices[index].apply();
                    gameState = 'PLAYING';
                    levelUpOverlay.classList.remove('visible');
                    gameLoop(); // ë£¨í”„ ì¬ì‹œì‘
                });
            });


            // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
            function findNearestEnemy(x, y, maxDist = Infinity) {
                let closestEnemy = null;
                let minDist = maxDist;
                enemies.forEach(enemy => {
                    const dist = Math.hypot(x - enemy.x, y - enemy.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestEnemy = enemy;
                    }
                });
                return closestEnemy;
            }
            
            function getRandomUpgrades(num) {
                const shuffled = [...UPGRADE_POOL].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, num);
            }

            // --- í•µì‹¬ í•¨ìˆ˜ ---

            function setupStartScreen(isGameOver = false) {
                gameState = 'START';
                if (isGameOver) {
                    finalScoreDisplay.textContent = `ìµœì¢… ì ìˆ˜: ${score}`;
                    finalScoreDisplay.style.display = 'block';
                    startButton.textContent = 'ë‹¤ì‹œí•˜ê¸°';
                } else {
                    finalScoreDisplay.style.display = 'none';
                    startButton.textContent = 'ì‹œì‘í•˜ê¸°';
                }
                gameOverlay.classList.add('visible');
            }

            function startGame() {
                score = 0;
                frameCount = 0;
                waveCount = 1;
                spawnInterval = 180; 
                nextSpawnFrame = 0;
                
                scoreDisplay.textContent = `Score: 0`;
                
                player = new Player();
                levelDisplay.textContent = `Lv. ${player.level}`;
                expBar.style.transform = `scaleX(0)`;
                
                enemies = [];
                projectiles = [];
                echoes = [];

                gameState = 'PLAYING';
                gameOverlay.classList.remove('visible');
                
                gameLoop(); // ë£¨í”„ ì‹œì‘
            }

            function endGame() {
                gameState = 'OVER';
                cancelAnimationFrame(gameLoopId);
                setupStartScreen(true); 
            }
            
            // ìŠ¤í° ë¡œì§ (ìˆ˜ì •ë¨)
            function spawnEnemies() {
                frameCount++;
                
                // 10ì´ˆê¹Œì§€ëŠ” 3ì´ˆì— 1ë§ˆë¦¬
                if (frameCount < 600 && frameCount % 180 !== 0) {
                    if (frameCount === 60) { // 1ì´ˆ ë’¤ 1ë§ˆë¦¬ ìŠ¤í° (íŠœí† ë¦¬ì–¼ìš©)
                         enemies.push(new Enemy(VIEWPORT_WIDTH / 2, 50, 'skeleton'));
                    }
                    return;
                }
                
                if (frameCount > nextSpawnFrame) {
                    for(let i=0; i < waveCount; i++) {
                        const x = Math.random() < 0.5 ? -20 : VIEWPORT_WIDTH + 20;
                        const y = Math.random() * VIEWPORT_HEIGHT;
                        const type = MOB_TYPES[Math.floor(Math.random() * MOB_TYPES.length)];
                        enemies.push(new Enemy(x, y, type));
                    }
                    nextSpawnFrame = frameCount + spawnInterval;
                }
                
                // 30ì´ˆë§ˆë‹¤ ë‚œì´ë„ ìƒìŠ¹
                if (frameCount % 1800 === 0 && frameCount > 0) { 
                    spawnInterval = Math.max(30, spawnInterval * 0.9); 
                    waveCount = Math.min(10, waveCount + 1); 
                }
            }
            
            function checkCollisions() {
                // 1. ìœ ë ¹ + ì  -> ê²Œì„ ì˜¤ë²„
                if (player.state === 'WISP') { 
                    for (const enemy of enemies) {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                            endGame();
                            return; 
                        }
                    }
                }
                
                // 2. íˆ¬ì‚¬ì²´ + ì 
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    let projectileHit = false;
                    
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (Math.hypot(p.x - e.x, p.y - e.y) < e.radius) {
                            e.takeDamage(p.damage);
                            projectileHit = true;
                        }
                    }
                    
                    if (projectileHit && p.type !== 'explosion') {
                        projectiles.splice(i, 1);
                    }
                }
                
                // 3. í”Œë ˆì´ì–´ + ì—ì½”
                for (let i = echoes.length - 1; i >= 0; i--) {
                    const e = echoes[i];
                    if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius + 10) {
                        player.collectExp(e.value);
                        echoes.splice(i, 1);
                    }
                }
            }

            // --- ë©”ì¸ ê²Œì„ ë£¨í”„ ---
            function gameLoop() {
                if (gameState !== 'PLAYING') {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                gameLoopId = requestAnimationFrame(gameLoop);

                // 1. í´ë¦¬ì–´
                ctx.fillStyle = "#2a2a3e";
                ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
                
                // 2. ìƒì„±
                spawnEnemies();
                
                // 3. ì—…ë°ì´íŠ¸
                player.update();
                enemies.forEach(e => e.update());
                projectiles.forEach(p => p.update());
                echoes.forEach(e => e.update());
                
                // 4. ì¶©ëŒ
                checkCollisions();
                
                // 5. ê·¸ë¦¬ê¸°
                projectiles.forEach(p => p.draw());
                echoes.forEach(e => e.draw());
                enemies.forEach(e => e.draw());
                player.draw(); 
                
                // 6. íˆ¬ì‚¬ì²´ ì œê±° (ìˆ˜ëª…)
                projectiles = projectiles.filter(p => p.life > 0);
            }
            
            // ì´ˆê¸° í™”ë©´ ì„¤ì •
            setupStartScreen();
        });
    </script>

</body>
</html>
